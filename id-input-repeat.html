<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../id-button/id-button.html">
<link rel="import" href="./id-input-repeat-row.html">

<!--
`id-form`
Idaho Form element that can validate and submit any form elements that are bound to the data object.

## Constraints
Data is validated against constraints. The constraints object can specify one or more validation rules for a field.
```js
var constraints = {
  email: {
    presence: true,
    email: true
  },
  password: {
    presence: true
  }
}
```
The library includes a collection of built-in validators and errors messages. Error messages can be customized, and you can also define custom validators for validating single, or multiple fields. Constraints can also be specified for child objects.
> <i>For more information, see the [Validate.js](https://validatejs.org/#constraints) documentation.</i>

@demo demo/index.html
-->

<dom-module id="id-input-repeat">
  <template>
    <style include="id-form-styles">
      :host {
        display: block;
        position: relative;
        margin-bottom: 0;
      }

      #original {
        display: none;
      }

    </style>

    <div id="original">
      <slot id="content"></slot>
    </div>
    <div id="repeats">
      <template is="dom-repeat" items="{{bindValue}}">
        <id-input-repeat-row
          value="{{item}}"
          repeats="[[repeatFields]]"
          repeat-label="[[repeatLabel]]"
          repeat-index="[[index]]"
          repeat-button-text="[[repeatButtonText]]"
          repeat-last="[[__isLastIndex(index, bindValue.length)]]"
          invalid="[[__isValid(index, invalid)]]"
          on-add-repeat="addRow"
          on-clear-empty="__clearEmpty">
        </id-input-repeat-row>
      </template>
    </div>
  </template>

  <script>
    class IdInputRepeat extends Polymer.MutableData(Polymer.Element) {
      static get is() { return 'id-input-repeat'; }
      static get properties() {
        return {
          /**
           * The value for this input.
          **/
          bindValue: {
            type: Array,
            notify: true,
          },
          /**
           * Repeat the label for additional rows.
           */
          repeatLabel: {
            type: Boolean,
            value: false
          },
          /**
           * Clear empty rows on blur
           */
          clearEmptyOnBlur: {
            type: Boolean,
            value: false
          },
          /**
           * What to add to the repeat button.
           */
          repeatButtonText: {
            type: String,
            value: 'Add'
          },
          /**
           * Invalid array for highlighting rows.
           */
          invalid: {
            type: Array,
            value: []
          }
        }
      }

      /**
       * Sets the invalid boolean for styling.
       * @param  {boolean} valid Is the input valid or not.
       * @return null
       */
      validate(valid) {
        if (valid.constructor === Array) {
          this.set('invalid', valid);
        } else {
          this.set('invalid', []);
        }

        this.set('bindValue', this.bindValue.filter(x => x !== ''));
        if (!this.bindValue.length) this.set('bindValue', ['']);
      }

      /**
       * Check if repeat is valid
       * @param  {number}  index   Index of element
       * @param  {array}   invalid Invalid array to check
       * @return {Boolean}
       */
      __isValid(index, invalid) {
        return (invalid[index] && (typeof invalid[index] !== 'number'));
      }

      /**
       * Checks if the row is the last. For button placement.
       * @param  {number}  index     Index of row.
       * @param  {array}   bindValue Repeatable element value.
       * @return {Boolean}           Whether or not it's the last.
       */
      __isLastIndex(index, bindValue) {
        return ((bindValue-1) === index);
      }

      /**
       * Adds a new row to the array.
       * @param {object} e Event from button.
       */
      addRow(e) {
        if (e) {
          e.stopPropagation();
        }

        if (this.bindValue[this.bindValue.length -1] === '') {
          return;
        }

        if (this.repeatFields.length > 1) {
          this.push('bindValue', {});
        } else {
          this.push('bindValue', '');
        }
      }

      /**
       * Finds repeatable fields in the slot
       * @return {array} Repeatable fields.
       */
      __getRepeatableFields() {
        let repeatFields = this.$.content.assignedNodes().filter(field => !field.disabled && field.name);

        if (repeatFields.length > 1 && !this.bindValue.length) {
          this.bindValue[0] = {};
        }

        return repeatFields;
      }

      /**
       * Clears empty fields on blur
       * @param  {object} e Event from blur
       * @return {null}
       */
      __clearEmpty(e) {
        if (this.clearEmptyOnBlur && this.bindValue.length > 1) {
          this.splice('bindValue', e.detail.index, 1);
        }
      }

      ready() {
        super.ready();
        this.repeatFields = this.__getRepeatableFields();

        if (!this.bindValue.length) {
          this.bindValue = [''];
        }
      }
    }

    window.customElements.define(IdInputRepeat.is, IdInputRepeat);
  </script>
</dom-module>
